---

layout: post
title: 给你讲设计模式之预备式
date: 2016-09-09
categories: blog
tags: [设计模式]
description: 简介面向对象的基础，就是讲语言基础同步，不能出现对某些词汇理解不同的现象。

---

## 目录

<ul>
    <li><a href="#对象、类以及实例">对象、类以及实例</a></li>
    <li><a href="#构造方法">构造方法</a></li>
    <li><a href="#方法重载">方法重载</a></li>
    <li><a href="#属性和修饰符">属性和修饰符</a></li>
    <li><a href="#面向对象的三大特性">面向对象的三大特性</a></li>
    <ol>
    <li><a href="#封装">    封装</a></li>
    <li><a href="#继承">    继承</a></li>
    <li><a href="#多态">    多态</a></li>
	</ol>
    <li><a href="#重构">重构</a></li>
    <li><a href="#抽象类和接口">抽象类和接口</a></li>
</ul>

---

<a id="对象、类以及实例"></a>

## 对象、类以及实例

#### 对象

一切事物皆为对象，即所有的东西都可以称之为对象，准确的说，**对象是一个自包含的实体，用一组可识别的特性和行为来标识。** 面对对象编程（ **Object-Oriented Programing** ），其实就是针对对象来进行编程的意思。

#### 类

类是现实世界或思维世界中的实体在计算机中的反映，它将数据以及这些数据上的操作封装在一起。 **类就是具有相同的属性和功能的对象的抽象的集合** 主要还是看图 ![](http://ocp77h2r6.bkt.clouddn.com/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1.jpg) 

#### 实例

实例，就是一个真实的对象。比如我们都是“人”，而你和我就算是“人”的实例了。实例化就是创建对象的过程，使用new关键字来创建。

---

<a id="构造方法"></a>

## 构造方法

构造方法，又叫做构造函数，其实就是对类进行初始化。构造方法与类同名，没有返回值，也不需要void，在new的时候调用。所有的类都有构造方法，如果你不定义系统就会自动生成一个空的构造方法；若你定义了构造方法，那么默认的构造方法就会失效。通俗地讲，你建立一个类，里面有许多的属性，在你实例化类的时候，需要对这些属性赋值，如果你没有写构造方法，他的属性就会默认为空值（注意 **空值也是需要赋值的** ，要不然出现monster就恐怖了），有时候需要给某些属性赋值，利用构造方法就可以实现。

补一个构造方法和普通方法的区别.

- 构造方法：只有构造方法才能new，用于生成实例对象，可以分配内存空间等。
- 普通方法：普通方法不能new，但可以通过对象名来调用。在对象有内存空间后可以处理类成员变量和调用其他的方法。

 ---

<a id="方法重载"></a>

## 方法重载

 方法重载是让类以统一的方式处理不同类型数据的一种手段。Java的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的含义。调用方法时通过传递给它们的不同个数和类型的参数来决定具体使用哪个方法。这个很简单，就是方法名相同而参数的类型或个数不相同，从而达到不改变原方法的基础上，新增功能的目的。
 
 方法重载的规范还是比较重要的
 
 - 1、方法名一定要相同。
 - 2、方法的参数表必须不同，包括参数的类型或个数，以此区分不同的方法体。
 	- 如果参数个数不同，就不管它的参数类型了！
 	- 如果参数个数相同，那么参数的类型或者参数的顺序必须不同。
 - 3、方法的返回类型、修饰符可以相同，也可不同。

---

<a id="属性和修饰符"></a>

## 属性和修饰符

**属性** 是一个方法或一对方法，但在调用它的代码来看，它是一个字段，即属性适合于以字段的方法调用的场合。

**字段** 是存储类要满足其设计要求的数据，字段是与类相关的变量。

举个栗子： ![](http://ocp77h2r6.bkt.clouddn.com/%E5%B1%9E%E6%80%A7%E4%B8%8E%E5%AD%97%E6%AE%B5.PNG)

**修饰符** 可以分为三类：

- 访问修饰符
	- 1、**public:** 访问不受限制，可以被随意引用。
		- 公有的、类名、成员变量、成员方法、构造函数，访问权限修饰符不能用于局部变量。
	- 2、**protected:** 访问仅限于包含类或从包含类派生的类型。只有包含该成员的类以及继承的类可以存取。
		- 规范的开发中不去使用，因为不准确。
	- 3、**Internal:** 访问仅限于当前程序集，只有当前工程可以存取。
	- 4、**protected internal:** 访问仅限于当前程序集或从包含类派生的类型。
	- 5、**private** 访问仅限于包含类型，只有包含该成员的类可以存取。

- 类修饰符
	- 6、  **abstract:** 可以被指示一个类只能作为其它类的基类，声明为 abstract 成员可以不包括实现代码，但只要类中还有未实现的抽象成员（抽象方法），那么这个类就是一个抽象类，抽象类的对象就不能被实例化，通常用于强制继承类必须实现某一成员.抽象类是必须要派生子类的。并且，如果子类没有实现抽象基类的所有方法，则子类也成为一个抽象类。
	- 7、**sealed:** sealed:指示一个类不能被继承.
	- 8、**static:** 修饰类时表示该类是静态类，不能够实例化该类的对象,该类的成员为静态.

- 成员修饰符
	- 9、**abstract:** 指示该方法或属性没有实现.
	- 10、**const:** 指定域或局部变量的值不可被改动.
	- 11、**event:** 声明一个事件.
	- 12、**extern:** 指示方法在外部实现.
	- 13、**override:** 对由基类继承成员的新实现，覆盖类。
	- 14、**readonly:** 指示一个域只能在声明时以及相同类的内部被赋值.

---

<a id="面向对象的三大特性"></a>

## 面向对象的三大特性

---

<a id="封装"></a>

封装(Encapsulation)|把对象的属性和方法结合成一个独立的单位，并尽可能隐蔽对象的内部细节。

封装包含以下两个基本涵义：

- 把对象的全部属性数据和对数据的全部操作(方法)结合在一起，形成一个不可分割的独立单位，也就是对象。
- 信息隐蔽，即尽可能地隐藏对象的内部细节，只保留有限的对外接口，对数据的操作都通过这些接口实现。

封装的原则在软件上的反映是：要求使对象以外的部分不能随意存取对象的内部数据(属性)，从而有效的避免了外部错误对它的“交叉感染”，这样就可以使软件错误局部化，大大减少查错和排错的难度。

封装的优点：

- 良好的封装能够减少 <a href="http://www.cnblogs.com/ElvisZhongShao/p/3940771.html/" target="_blank">耦合</a> ，菜刀是菜刀，厨房是厨房，不让菜刀锁死在厨房这个类中，菜刀就会有更大的用途。
- 类内部的实现可以自由地进行修改，而不会受到外界的影响，而且也不会影响外界。
- 类具有清晰的对外接口，就像房间的门窗一样，专门用来与外界沟通。

---

<a id="继承"></a>

继承(Inheritance)|它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。通过继承创建的新类称为“子类”(Subclass,派生类)。被继承的类称为“基类”(Superclass，超类，父类)。继承的过程，就是从一般到特殊的过程。要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。

继承概念的实现方式有三类：实现继承、接口继承和可视继承。
 
- 实现继承是指使用基类的属性和方法而无需额外编码的能力；
- 接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力； 
- 可视继承是指子类使用基类的外观和实现代码的能力。
 
在考虑使用继承时，有一点需要注意，那就是两个类之间的关系应该是“属于”关系。例如，Employee 是一个人，Manager 也是一个人，因此这两个类都可以继承 Person 类。但是 Leg 类却不能继承 Person 类，因为腿并不是一个人。

继承的优点： 

- 容易进行新的实现，因为其大多数可继承而来。 
- 易于修改或扩展那些被复用的实现。 

继承的缺点： 

- 破坏了封装性，因为这会将父类的实现细节暴露给子类。 
- “白盒”复用，因为父类的内部细节对于子类而言通常是可见的。 
- 当父类的实现更改时，子类也不得不会随之更改。 
- 从父类继承来的实现将不能在运行期间进行改变。

---

<a id="多态"></a>

多态(Polymorphism)|是指在一般类中定义的属性或方法被特殊类继承之后，可以具有不同的数据类型或表现出不同的行为。这使得同一个属性或方法在一般类及其各个特殊类中具有不同的语义。例如：“椭圆”和“多边形”都是“几何图形”的子类，那么在“几何图形”中的定义“绘图”方法，与其两个子类中定义的“绘图”方法在功能上显然不同。在原理上说就是：允许将子类类型的指针赋值给父类类型的指针。

实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。
多态的作用：消除类型之间的耦合关系。
现实中，关于多态的例子不胜枚举。比方说按下 F1 键这个动作，如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；如果当前在 Word 下弹出的就是 Word 帮助；在 Windows 下弹出的就是 Windows 帮助和支持。同一个事件发生在不同的对象上会产生不同的结果。
下面是多态存在的三个必要条件，要求大家做梦时都能背出来！

多态存在的三个必要条件

- 1、 要有继承；
- 2、 要有重写；
- 3、 父类引用指向子类对象。

多态的好处：

- 可替换性（substitutability）。多态对已存在代码具有可替换性。例如，多态对圆Circle类工作，对其他任何圆形几何体，如圆环，也同样工作。
- 可扩充性（extensibility）。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多态基础上，很容易增添球体类的多态性。
- 接口性（interface-ability）。多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。如图8.3 所示。图中超类Shape规定了两个实现多态的接口方法，computeArea()以及computeVolume()。子类，如Circle和Sphere为了实现多态，完善或者覆盖这两个接口方法。
- 灵活性（flexibility）。它在应用中体现了灵活多样的操作，提高了使用效率。
- 简化性（simplicity）。多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。

由于多态这部分比较难一点，可以说前面的封装和继承是为他服务的，我在这里放了一个小题目，希望能帮助理解。
如果想跳过题目请点击<a href="#重构">重构</a>

---

<h2>一、相关类</h2>

```
class A ...{  
         public String show(D obj)...{  
                return ("A and D");  
         }   
         public String show(A obj)...{  
                return ("A and A");  
         }   
}   
class B extends A...{  
         public String show(B obj)...{  
                return ("B and B");  
         }  
         public String show(A obj)...{  
                return ("B and A");  
         }   
}  
class C extends B...{}   
class D extends B...{}  
```

<h2>二、问题：以下输出结果是什么？</h2>

```
A a1 = new A();  
        A a2 = new B();  
        B b = new B();  
        C c = new C();   
        D d = new D();   
        System.out.println(a1.show(b));   ①  
        System.out.println(a1.show(c));   ②  
        System.out.println(a1.show(d));   ③  
        System.out.println(a2.show(b));   ④  
        System.out.println(a2.show(c));   ⑤  
        System.out.println(a2.show(d));   ⑥  
        System.out.println(b.show(b));    ⑦  
        System.out.println(b.show(c));    ⑧  
        System.out.println(b.show(d));    ⑨     
```
 

<h2>三、答案</h2>

```
①   A and A
②   A and A
③   A and D
④   B and A
⑤   B and A
⑥   A and D
⑦   B and B
⑧   B and B
⑨   A and D
```

---

<a id="重构"></a>

## 重构

重构(Refactoring)|就是在不改变软件现有功能的基础上，通过调整程序代码改善软件的质量、性能，使其程序的设计模式和架构更趋合理，提高软件的扩展性和维护性。

重构的优点

- 持续偏纠和改进软件设计
- 使代码更易为人所理解
- 帮助发现隐藏的代码缺陷
- 从长远来看，有助于提高编程效率

---

<a id="抽象类和接口"></a>

## 抽象类和接口

Java接口和Java抽象类代表的就是抽象类型，就是需要提出的抽象层的具体表现。OOP面向对象的编程，如果要提高程序的复用率，增加程序的可维护性，可扩展性，就必须是面向接口的编程，面向抽象的编程，正确地使用接口、抽象类这些太有用的抽象类型做为java结构层次上的顶层。

抽象类(abstract)|往往用来表征对问题领域进行分析、设计中得出的抽象概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象。

抽象类是不完整的，它只能用作基类。在面向对象方法中，抽象类主要用来进行类型隐藏和充当全局变量的角色。

比如：如果我们进行一个图形编辑软件的开发，就会发现问题领域存在着圆、三角形这样一些具体概念，它们是不同的，但是它们又都属于形状这样一个概念，形状这个概念在问题领域是不存在的，它就是一个抽象概念。正是因为抽象的概念在问题领域没有对应的具体概念，所以用以表征抽象概念的抽象类是不能够实例化的。  在面向对象领域，抽象类主要用来进行类型隐藏。我们可以构造出一个固定的一组行为的抽象描述，但是这组行为却能够有任意个可能的具体实现方式。这个抽象描述就是抽象类，而这一组任意个可能的具体实现则表现为所有可能的派生类。

接口(interface)|泛指实体把自己提供给外界的一种抽象化物
 
接口用以由内部操作分离出外部沟通方法，使其能被修改内部而不影响外界其他实体与其交互的方式，就如面向对象程序设计提供的多重抽象化。

#### 接口与抽象类的区别：

1、Java接口和Java抽象类最大的一个区别，就在于Java抽象类可以提供某些方法的部分实现，而Java接口不可以，这大概就是Java抽象类唯一的优点吧，但这个优点非常有用。如果向一个抽象类里加入一个新的具体方法时，那么它所有的子类都一下子都得到了这个新方法，而Java接口做不到这一点，如果向一个Java接口里加入一个新方法，所有实现这个接口的类就无法成功通过编译了，因为你必须让每一个类都再实现这个方法才行，这显然是Java接口的缺点(因为抽象类用的是继承，属于全部引用，而就像一个目录，每次给你一个链接，具体还要再实现一次)。

2、一个抽象类的实现只能由这个抽象类的子类给出，也就是说，这个实现处在抽象类所定义出的继承的等级结构中，而由于Java语言的单继承性，所以抽象类作为类型定义工具的效能大打折扣。在这一点上，Java接口的优势就出来了，任何一个实现了一个Java接口所规定的方法的类都可以具有这个接口的类型，而一个类可以实现任意多个Java接口，从而这个类就有了多种类型(五毛钱和一毛钱的区别)。

3、从第2点不难看出，Java接口是定义混合类型的理想工具，混合类表明一个类不仅仅具有某个主类型的行为，而且具有其他的次要行为。

#### 接口与抽象类各自的优缺：

抽象类的缺点：一个类只能由一个超类继承，所以抽象类作为类型定义工具的效能大打折扣。

抽象类的优点：具体类可从抽象类自动得到这些方法的缺省实现。

接口缺点：如果向一个java接口加入一个新的方法时，所有实现这个接口的类都得编写具体的实现。

接口优点：一个类可以实现多个接口，接口可以让这个类不仅具有主类型的行为，而且具有其他的次要行为，比如 HashMap主要类型是Map,而Cloneable接口使它具有一个次要类型，这个类型说明它可以安全的克隆.

<a href="http://blog.csdn.net/springsen/article/details/7820320 " target="_blank">抽象类与接口的详细概念</a> 

---

<a href="http://pan.baidu.com/s/1gfe9C4b " target="_blank">委托的C#实现</a>

占个坑，以后会补泛型，记得提醒我哦！

---
