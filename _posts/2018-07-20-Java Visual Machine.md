---
layout: post
title: Java虚拟机(jvm)
date: 2018-07-20
categories: blog
tags: [java]
description: 一句话描述。
---

[TOC]

## java 技术体系

- Java程设计语言
- 各种硬件平台上的Java虚拟机
- Class文件格式
- JavaAPI 类库
- 来自商业机构和开源社区的第三方Java类库

    Java程序设计语言,Java虚拟机,JavaAPI类库这三部分统称为JDK(Java Development Kit)JDK是用于支持Java程序开发的最小环境
    Java API 类库中的Java SE API 子集和Java虚拟机这两部分统称为JRE (Java Runtime Environment),JRE是支持Java程序运行的标准环境


## java内存区域

### 运行时数据区域

##### 程序计数器

- 程序计数器是一块较小的内存空间，，可以看作是当前线程所执行的字节码的行号指示器。
- 每一条线程都需要一个独立的程序计数器，各线程之间计数器互不影响，独立存储。
- 此区域是唯一一个java虚拟机没有规定任何OutOfMemoryError的地方。
##### java虚拟机栈

- java虚拟机栈是线程私有的
- java虚拟机栈描述的是java方法执行的内存模型，即每一个方法在执行时都会生成一个栈帧
- 栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息；
- 异常：如果线程请求的栈深度大于虚拟机所允许的深度将抛出StackOverflowError异常,无法在申请到足够的内存时，将抛出OutOfMememoryError

##### 本地方法栈
- 虚拟机栈是为虚拟机执行的java方法（字节码）服务，而本地方法栈则为虚拟机使用到的native方法；
##### java堆
- java堆是java虚拟机所管理的内存中最大的一块
- java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建；
- 此内存区域的唯一目的就是存放对象实例，几乎所有对象都是在这里分配内存
- java堆是垃圾收集器管理的主要区域，因此也被称为GC堆
##### 方法区
- 方法区和java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译的代码等数据。
- java虚拟机规范把方法去描述为堆的一个逻辑部分
###### 运行时常量池
- 运行时常量池是方法区的一部分。

> 直接内存是java虚拟机直接分配的堆外内存，通过存储在java堆中的DirectByteBuffer对象的引用进行操作。
> 这里需要特别关注的是该内存不容易控制，极容易产生内存溢出异常。

##### 对象的内存布局
- 对象在内存中存储的布局可以分为3块区域:对象头(Header),示例数据(Instance Data),和对齐填充(Padding)
    - 对象头包含两部分信息,
        - 第一部分用于存储对象自身的运行时数据,如hashCode,GC粉黛年龄,锁状态标志,线程持有的锁,偏向线程ID,偏向时间戳等,此部分又被称为:Mark Word
        - 另外一部分是类型指针,即对象指向他的类元数据的指针,虚拟机通过这个指针俩确定这个对象是哪个类的实例.查找对象的元数据信息并不一定要经过对象本身
    - 实例数据部分是对象真正存储的有效信息,也是在程序代码中所定义的各种类的字段内容.无论是从父类继承下来的,还是在子类中定义的,都需要记录下来.
    - 第三部分Padding并不是必然存在的,也没有特别的含义,他仅仅起着占位符的作用

- 句柄池和直接指针访问
    - 使用直接指针的最大好处是速度更快,节省一次指针的时间开销,由于对象的访问在java中非常的频繁,因此这类开销十分可观,就HotSpot而言,使用的是直接指针访问对象.
    - 使用句柄池的话,java栈中的本地变量表首先指向句柄,然后再指向实例池的实例数据.在对象被移动时只会改变句柄中的实例数据指针.

> 如果线程请求的栈深度大于虚拟机所允许的最大深度,将抛出StackOverFlowError异常;
> 如果虚拟机在扩展栈时无法申请到足够的内存空间,则抛出OutOfMemoryError异常;

## 垃圾收集(Garbage Collection)

### 如何判断对象是否存活
- 引用计数算法
    - 在对象中添加一个引用计数器,每当有人引用,i++,引用失效时,i-- ,当计数器回归为零时,即代表对象不可能再被使用.
    - 但是当对象出现循环引用时,而整个循环内的对象都已经不可能再被引用,但由于计数器不为0,使得无法GC

- 可达性分析算法
    - 当一个对象到GC Root是没有任何引用链时,则证明此对象是不可用的

#### 引用的四个类型
- 强引用,是指代码中明确表明正在使用的引用,只要强引用一直存在,垃圾回收器永不回收该对象
- 软引用,用于描述一些有用但并非必须的对象,在系统将要发生内存溢出之前,将会把这些对象进行二次回收.如果二次回收还是内存不足,则会抛出内存溢出异常.
- 弱引用,被弱引用关联的对象智能生存到下一次垃圾回收之前,当进行垃圾回收时,将会回收只被弱引用引用的对象.
- 虚引用,属于最弱的引用,为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知.
- finalize()函数可以让对象在回收队列时,如果被引用就会启动自救,让对象不被回收.但它的运行代价高昂,是实际效果不明显,建议不使用.
- 回收方法区
    - 方法区使用垃圾回收的,但是性价比较低,方法区又被称为永久代,主要在永久代可以回收的是废弃常量和无用的类.
      ###垃圾回收算法
- 标记-清除算法
    - 算法分为标记和清除两部分,首先标记需要清理的内容,然后在统一清理
    - 但是这样清理出来的空间会产生大量不连续,分配大对象时比较麻烦,而且标记和清除的两个过程的效率都不高
- 复制算法
    - 将内存分为两块,每次只用一半,需要清理时,无需清理的复制到另外一块内存,然后清空当前的内存块
    - 这样无疑有些太耗空间,于是进行改进,将内存分为一块较大的Eden区和两块较小的Survivor区,每次使用Eden区和其中的一个Survivor区,当回收时,将Eden区和Survivor区的存活对象复制到另外一块Survivor中,最后清理正在使用过的一大一小空间.HotSpot默认Eden和Survivor大小比例是8:1;每次只浪费了10%的空间.
- 标记整理算法
- Stop the World 之后简写为STW

- 并行(Parallel):指多条垃圾收集器线程并行工作,但此时用户线程依旧处于等待状态.
- 并发(Concurrent):指用户线程与垃圾收集线程同时执行(但不一定是并行的,可能会交替执行),用户程序在继续运行,而垃圾收集程序运行在另一个CPU上.

### 垃圾收集器
#### Serial 收集器
    新生代/老年代的收集器,只支持单线程,需要STW ,运行在Client端效果较好,在新生代使用复制,老年代使用标记整理
#### ParNew 收集器
    Serial收集器的多线程版本,目前只有其能和CMS收集器配合工作.ParNew常用于Server的新生代的垃圾收集
#### Parallel Scavenge 收集器
    新生代收集器,使用了复制算法,支持并行多线程
    它的关注点并不是单次停顿时间的长短,其目标是达到一个可控制的吞吐量,就是指CPU用于运行用户代码的时间与CPU的总消耗时间的比值.
    这使得它更适应于后台运算而不需要太多交互的任务.
#### Parallel Old
    使用多线程和标记清理算法,用于和新生代的Parallel共同完成收集工作
#### CMS收集器(Concurrent Mark Sweep)
    是一种以获取最短回收停顿时间为目标的收集器.标记阶段需要STW,但之后就可以并发的清理了,CMS比较耗费CPU资源,因为他在清理时需要占一个线程专门去清理,使得系统的运行变慢.
#### G1收集器
    利用并发和并行,使减少STW的时间,使用分代收集,但是不需要其他的收集器的配合,可以独立完成.
    其将java堆分为多个region,新生代和老年代都是一部分region,每次只对其中一个region进行收集,而且其可以预测收集的停顿时间,
    这样的分区操作使得收集变得更加高效,其也一定程度上解决了不同区的相互调用的问题,保证分区清理时不会漏掉跨区的对象实例.

- 大对象会直接进入老年代,否则大对象容易塞满Survivor区,导致提前触发新生代GC或太大导致数据进入老年代,使得回收低下.
- 长期存活的对象进入老年代
- 动态的对象年龄判断
- 空间分配担保
  ​              
### JVM的使用
- 64位虚拟机应该尽量减少Full GC的次数,因为对于大内存的GC消耗的时间可能会很长,影响及时响应
- 64位虚拟机较适应于绝大多数都是朝生夕灭的新生代,尽量不触发老年代GC的系统
- 如果有大对象,应该使用多个32位的虚拟机建立逻辑集群利用硬件资源.
- 现阶段64位性能低于32位,而且64位更加消耗内存,是因为指针膨胀和数据类型对齐补白导致

## 虚拟机类加载机制
- 加载
    - 通过一个类的全限定名来获取定义此类的二进制字节流
    - 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
    - 在内存生成一个代表这个类的java.lang.Class对象,作为方法区这个类的各种数据的访问入口
- 验证
    - 验证是连接阶段的第一步,这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求,并且不会危害虚拟机自身恶安全.
    - 文件格式验证
    - 元数据验证
    - 字节码验证
    - 符号引用验证
- 准备
    - 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段,这些变量所使用的内存都将在方法区中进行分配.
- 解析
    - 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程,
    - 符号引用与虚拟机的内存布局无关,
    - 直接引用可以使直接指向目标指向目标的指针.相对偏移量或是一个能间接定位到目标的句柄.
    - 解析动作主要针对类或接口,字段,类方法,接口方法,方法类型,方法句柄和调用点限定符进行.
- 初始化
    - 在初始化阶段开始真正执行类中定义的java程序代码
    - 在准备阶段,变量已经赋值一次系统要求的初始值,而在初始化阶段,则根据程序员通过程序指定的主观计划去初始化类变量和其他资源.

## 虚拟机字节码执行引擎

- 运行时栈帧结构
    - 栈帧是用于支持虚拟机运行时数据区中的虚拟机栈的栈元素.栈帧存储了方法的局部变量表,操作数栈,动态链接和方法返回地址;
### 分派
- 静态分派(method overload resolution方法重载解析)
    - 重载时会选择与重载方法最接近的类型,如果有human,man和woman中human为重载时,会逐次选择Human>man>woman先选man再选woman是因为使用顺序在前.
- 动态分派
    - 动态分派是多态的实现基础,先选择子类在选择父类
### 编译执行和解释执行
- 编译执行
    - 是利用事先编写好的成为编写程序的机器语言程序，作为系统软件存放在计算机内，当高级语言源程序进入计算机，被这个翻译成目标程序，以完成源码要处理的运算并取得结果

- 解释方式
    - 是源程序进入计算机内，解释程序边扫描边解释，逐句输入逐句翻译，计算机一步一步执行，并不产生目标程序

## Web服务器
- 服务器的作用
    -  部署在同一个服务器上的两个应用程序类库可以实现相互隔离
    -  部署在同一个服务器上的两个应用程序类库可以实现相互共享
    -  服务器应尽可能保证自身的安全不受部署的Web应用的影响
    -  支持JSP的Web服务器,大多数都需要支持HotSwap功能

    ### 动态代理
    - 