```
layout: post
title: 红黑树(red black tree)
date: 2018-07-25
categories: blog
tags: [java,算法]
description: 
```

[TOC]

### case1：D为红色，DL为NIL（黑色）

    因为D为红色，不会影响性质5，故可以直接删除D，将DR接在P[DR]下；

### case2-1：D为黑色，DR为红色

    因为D整个方向少一个黑节点，故需要让D方向补一个黑节点，让红色的DR继承D，并将自己的颜色改为黑色可保证性质5

### case2-2：D为黑色，DR为NIL

    先删除D，用DR（NIL）来代替D的位置。此时，删除后D的整个方向会缺少一个黑节点，由于节点均为NIL，故需要引用P的another(S)节点来辅助增加一个黑节点；

#### case 2-2-1：兄弟节点为红色，P必为黑色

    因为S为红色，父亲节点就必须为黑色，需要以P为支点左旋，P变为红色，S变为黑色，即可平衡支点；

#### case 2-2-2：兄弟节点为黑色，P颜色无法确定

    当知道兄弟节点为黑色时，P、SL、SR都无法确定，无法进行操作，故需要分情况讨论；

##### case 2-2-2-1：SL红色，SR任意颜色

    因为SL的子节点一定是NIL，就可以使用SL代替P的位置，让P作为自己的左子节点，然后把SL的颜色改为P的颜色，P的颜色改为黑色；

##### case 2-2-2-2： SR红色，SL为黑色

    经过上面的case，SL只会有黑色的情况，
        (01) 将x父节点颜色 赋值给 x的兄弟节点。
        (02) 将x父节点设为“黑色”。
        (03) 将x兄弟节点的右子节设为“黑色”。
        (04) 对x的父节点进行左旋。